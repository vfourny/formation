---
title: Introduction
<<<<<<< HEAD
description: "D√©couvrir les concepts frontend et le framework Vue.js"
=======
description: "D√©couvrez le fonctionnement d'un site web et de NodeJS"
>>>>>>> origin/feat/add-vuejs
icon: i-mdi-door-open
helper:
  title: 'Liens utiles'
  links:
<<<<<<< HEAD
=======
    - label: 'T√©l√©charger Node JS'
      icon: 'i-mdi-nodejs'
      to: 'https://nodejs.org/fr/'
      target: '_blank'
    - label: 'Doc Node JS'
      icon: 'i-mdi-nodejs'
      to: 'https://nodejs.org/docs/latest/api/'
    - label: 'Doc TypeScript'
      icon: 'i-mdi-language-typescript'
      to: 'https://www.typescriptlang.org/docs/'
      target: '_blank'
    - label: 'Doc Express'
      icon: 'i-mdi-api'
      to: 'https://expressjs.com/fr/'
      target: '_blank'
    - label: 'Installer Postman'
      icon: 'i-mdi-rocket-launch'
      to: 'https://www.postman.com/downloads/'
      target: '_blank'
    - label: 'Doc Prisma'
      icon: 'i-mdi-diamond-stone'
      to: 'https://www.prisma.io/docs/'
      target: '_blank'
    - label: 'Doc Jest'
      icon: 'i-mdi-test-tube'
      to: 'https://jestjs.io/fr/docs/api'
      target: '_blank'
    - label: 'Doc Swagger'
      icon: 'i-mdi-api'
      to: 'https://swagger.io/docs/specification/about/'
      target: '_blank'
>>>>>>> origin/feat/add-vuejs
exercises:
  title: 'Exercices'
  links:
    - label: 'Corrig√© du cours'
      icon: 'i-mdi-account-school'
      target: '_blank'
      to: 'https://github.com/Seyrinian/nodejs-tutorial/tree/main'
<<<<<<< HEAD
    - label: 'Pokemon TCG'
=======
    - label: 'API Pok√©mon'
>>>>>>> origin/feat/add-vuejs
      icon: 'i-mdi-pokeball'
      target: '_blank'
      to: 'https://classroom.github.com/a/1kY2YdAF'
---
<<<<<<< HEAD
# Introduction

## Pourquoi utiliser un framework front-end ?

Lorsque vous d√©veloppez une application web, vous pouvez choisir de coder votre interface utilisateur en utilisant des m√©thodes traditionnelles, comme du JavaScript pur ou jQuery. Cependant, ces m√©thodes peuvent rapidement devenir complexes et difficiles √† maintenir √† mesure que votre application grandit. Un framework front-end comme Vue.js vous permet de structurer votre code de mani√®re plus efficace et modulaire.

### Les avantages d'un framework front-end :

- **Modularit√©** : Le code est mieux structur√© gr√¢ce √† des composants r√©utilisables, facilitant ainsi la gestion du projet.
- **Maintenance simplifi√©e** : Un framework bien con√ßu facilite la mise √† jour de l'application et la correction des bugs.
- **Gain de productivit√©** : Avec des outils et des conventions int√©gr√©es, vous passez moins de temps √† configurer et plus de temps √† d√©velopper des fonctionnalit√©s.
- **R√©activit√©** : Un framework comme Vue.js rend l'interface utilisateur r√©active, c'est-√†-dire que l'UI se met √† jour automatiquement en fonction des modifications des donn√©es.

### üìå Pourquoi utiliser Vue.js ?

- **Facilit√© d'apprentissage** : Sa syntaxe est intuitive et la documentation est bien fournie.
- **Composants r√©utilisables** : Vue permet de structurer l'application en petits morceaux r√©utilisables, facilitant la gestion du code.
- **R√©activit√© int√©gr√©e** : Vue.js met √† jour automatiquement l'interface utilisateur en fonction des donn√©es, ce qui rend le d√©veloppement d'interfaces interactives tr√®s simple.
- **√âcosyst√®me complet** : Vue offre des outils comme Vue Router pour la navigation, Pinia pour la gestion d'√©tat, et Vite pour une compilation rapide.

## Installation et configuration

```sh
npm create vue@latest vujs-tutorial
cd vuejs-tutorial
npm install
npm run dev
```

### Bundler et Vite

Un outil de bundling pour le web est un logiciel qui prend en entr√©e plusieurs fichiers source (g√©n√©ralement du code JavaScript, mais aussi du CSS, des images, etc.) et qui les regroupe en un ou plusieurs fichiers "bundl√©s" optimis√©s pour √™tre d√©ploy√©s en production. L‚Äôobjectif principal est de r√©duire le nombre de requ√™tes HTTP, d‚Äôoptimiser la taille des fichiers (par exemple en supprimant les espaces inutiles ou en minifiant le code) et de g√©rer les d√©pendances de mani√®re efficace. Autrement dit, le bundler transforme une base de code modulaire en un format compr√©hensible et performant par les navigateurs web.

Vite se d√©marque particuli√®rement dans ce domaine pour plusieurs raisons :

| Caract√©ristique                | Description                                                                                                                                                  |
|--------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| D√©marrage ultra-rapide         | Utilise les modules ECMAScript natifs pour servir les fichiers √† la demande, √©vitant ainsi le build complet au d√©marrage.                                    |
| Pr√©-traitement des d√©pendances | Recourt √† esbuild pour pr√©-bundler rapidement les d√©pendances, r√©duisant la charge pendant le d√©veloppement.                                                  |
| Hot Module Replacement (HMR)   | Actualise uniquement les modules modifi√©s, offrant une exp√©rience de d√©veloppement plus fluide.                                                                |
| Configuration minimale         | Fonctionne avec peu, voire sans configuration initiale, permettant une int√©gration simple avec diff√©rents frameworks modernes (Vue, React, etc.).            |
| Production optimis√©e           | S'appuie sur Rollup pour g√©n√©rer des bundles performants et optimis√©s lors du d√©ploiement en production.                                                       |

Voici un compl√©ment de cours qui d√©crit comment l'instance Vue est initialis√©e gr√¢ce aux fichiers main.ts et App.vue, ainsi que leur r√¥le par rapport √† index.html.

---

## Initialisation de Vue avec main.ts et App.vue

### main.ts

Le fichier main.ts est le point d'entr√©e principal de l'application. C'est ici que l'instance Vue est cr√©√©e et que le composant racine (souvent App.vue) est mont√© dans l'√©l√©ment HTML pr√©vu √† cet effet, g√©n√©ralement d√©fini dans index.html. Un exemple typique de main.ts ressemble √† ceci :

```ts
// main.ts
import { createApp } from 'vue'
import App from './App.vue'

// Cr√©e une instance de l'application Vue √† partir du composant App
const app = createApp(App)

// Monte l'application dans l'√©l√©ment HTML qui a pour id "app"
app.mount('#app')
```

Les points cl√©s √† retenir :
- On importe la fonction `createApp` depuis Vue et le composant racine `App`.
- On cr√©e l'application avec `createApp(App)`.
- L'appel `mount('#app')` associe l'application √† l'√©l√©ment DOM dont l'id est "app". Cet √©l√©ment se trouve dans le fichier index.html.

### App.vue

Le fichier App.vue est le composant racine de l'application Vue. Il contient g√©n√©ralement trois sections principales :

1. Le bloc `<template>` qui d√©finit la structure HTML du composant.
2. Le bloc `<script>` qui contient la logique JavaScript (ou TypeScript) du composant.
3. Le bloc `<style>` qui permet d'ajouter des styles CSS sp√©cifiques √† ce composant.

Voici un exemple basique de structure d'un fichier App.vue :

```vue
<!-- App.vue -->
<template>
  <div id="app">
    <h1>Bienvenue dans l'application Vue.js</h1>
    <p>Ceci est le composant racine.</p>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'App'
  // Vous pouvez d√©finir ici les donn√©es, m√©thodes, etc.
})
</script>

<style>
/* Styles sp√©cifiques √† App.vue */
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  text-align: center;
}
</style>
```

Les points essentiels :
- Le `<template>` d√©finit le rendu visuel du composant.
- Le `<script>` contient la logique du composant (pour g√©rer l'√©tat, les m√©thodes, etc.).
- Le `<style>` permet de styliser le composant de mani√®re encapsul√©e.

### R√¥le par rapport √† index.html

Le fichier index.html est la page HTML principale qui charge l'application Vue. Il contient un √©l√©ment conteneur (souvent un div avec l'id "app") dans lequel Vue va injecter le contenu g√©n√©r√© par l'application.

Exemple simplifi√© de index.html :

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>Mon Application Vue</title>
  </head>
  <body>
    <!-- Point de montage pour l'application Vue -->
    <div id="app"></div>

    <!-- Le bundle g√©n√©r√© (incluant main.ts et App.vue compil√©s) est inject√© ici par Vite -->
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

Explications :
- Le `<div id="app"></div>` sert de conteneur dans lequel Vue montera l'application cr√©√©e dans main.ts.
- Le fichier main.ts est r√©f√©renc√© en tant que module JavaScript. Gr√¢ce √† ce chargement, l'instance Vue est cr√©√©e, le composant App.vue est rendu et tout le contenu de l'application est inject√© dans le conteneur d√©fini dans index.html.

---

En r√©sum√©, main.ts est le point d'entr√©e qui cr√©e et monte l'application Vue en ciblant un √©l√©ment pr√©d√©fini dans index.html, tandis que App.vue est le composant racine qui d√©finit l'interface et la logique initiale de l'application. Cette structure modulaire permet de s√©parer la configuration d'initialisation du rendu et de la logique de l'interface utilisateur, facilitant ainsi l'organisation et la maintenance du code.
=======

## Application full-stack

Lorsque vous acc√©dez √† un site web via votre navigateur vous utilisez une url. Basiquement, cette url permet une communication entre ordinateurs le votre et celui o√π le site est h√©berg√©. On appelle ces deux parties le client et le serveur.

#### C√¥t√© client (FRONTEND)

Le client c'est vous. Ce qui est charg√© du c√¥t√© de votre navigateur, comme les interactions avec la page. Les langages dit serveur (comme PHP, Ruby) ne traite pas les informations de ce c√¥t√©, c'est plut√¥t du ressort des langages client comme Javascript.

#### C√¥t√© serveur (BACKEND)

C'est la partie qui nous int√©resse. Les ordinateurs c√¥t√© serveurs sont diff√©rent des ordinateurs que les clients utilisent. Il s'agit d'ordinateur assez puissant, qui tournent nuit et jour et ne servent globalement qu'√† stocker et faire tourner des applications sur le web. Dans le cas d'une application web, elle va appeler via des requ√™tes API diff√©rents scripts qui vont s'ex√©cuter de ce c√¥t√©. Il peut s'agir d'appels √† une base de donn√©es, de traitements re√ßus par le client √† v√©rifier ou alors de donn√©es √† lui renvoyer.

#### Fonctionnement

Dans le cas d'un site dynamique, contrairement au statique ou le site est envoy√© en totalit√© au client et ce sans n√©cessiter de modifier la page en temps r√©el, le site dynamique lui va permettre une certaine interaction. En effet lorsque le client va ex√©cuter des actions pr√©cises, comme par exemple valider un formulaire d'inscription, ces informations de connexion vont √™tre envoy√© au serveur, √™tre v√©rifi√© et une r√©ponse va ensuite √™tre renvoy√© c√¥t√© client pour faire un affichage diff√©rent en fonction du cas d'une connexion r√©ussie ou non.

## NodeJS

Javascript permet √† la base la cr√©ation de site web dynamique. NodeJS est une biblioth√®que se basant sur javascript mais offrant la possibilit√© de g√©rer un backend. En d'autre terme il est interpr√©t√© c√¥t√© serveur et non plus c√¥t√© client (navigateur).
Bien que Node poss√®de ses propres caract√©ristiques il peut-√™tre en partie compar√©e √† des langages tel que PHP ou Ruby.

NodeJS permet principalement de g√©rer des interactions backend (c√¥t√© serveur). Et l'une de ses sp√©cificit√©s et notamment de g√©rer tr√®s bien les requ√™tes multiples asynchrones (qui n'ont pas lieu en m√™me temps).

#### **Diff√©rences cl√©s**

| **Caract√©ristique**        | **JavaScript (dans un navigateur)**      | **Node.js**                  |
| -------------------------- | ---------------------------------------- | ---------------------------- |
| **Contexte d'ex√©cution**   | Navigateur (Chrome, Firefox, etc.)       | C√¥t√© serveur                 |
| **Modules int√©gr√©s**       | Aucune, sauf via des APIs du DOM         | Oui (fs, http, path, etc.)   |
| **Gestion des fichiers**   | Non                                      | Oui (via le module `fs`)     |
| **Modules tiers**          | Non                                      | Oui, via **npm**             |
| **Utilisation principale** | Interaction utilisateur, DOM, animations | Backend, API, t√¢ches syst√®me |

#### NodeJS vs les autres

Les plates-formes web traditionnelles utilisent en g√©n√©ral un syst√®me de multi-threading (plusieurs thread en parall√®les) pour g√©rer la concurrence en leur sein, pour chaque requ√™te au serveur un thread se charge de la g√©rer, et il n‚Äôest lib√©r√© qu‚Äôune fois que les op√©rations demand√©es par la requ√™te en question sont achev√©es, le thread est donc bloqu√©. Une grande parti des op√©rations web sont des appels √† la base de donn√©es ou appel √† une api externe ry dony tr√®s consommateur de temps et de ressources. Ainsi le serveur se retrouve donc dans l‚Äôobligation de cr√©er autant de thread que de connexion.

Dans un contexte o√π le nombre de requ√™tes peut rapidement grimper (des milliers de connections en simultan√©), le multi-threading atteint rapidement ses limites, en effet il faut savoir que le serveur ne peut d√©passer un certain nombre de thread en simultan√©, et donc √† un moment donn√© faute de thread disponible, les nouvelles requ√™tes ne pourront plus √™tre prise en charge, et vont donc devoir se mettre en attente, ce qui impactera drastiquement les performance de l‚Äôapplication

Node.js en revanche est single-threaded, un seul et unique thread peut tourner √† la fois, √ßa peut sembler inefficient √† premi√®re vu compte tenu de l‚Äôinfrastructure multi coeurs que nous avons √† disposition aujourd‚Äôhui, mais ce qu‚Äôil faut savoir, c‚Äôest qu‚Äôen contrepartie la plupart des op√©rations sont non bloquantes, la nature asynchrone de ces derniers √©limine le besoin d‚Äôattente et permet ainsi au serveur de g√©rer des milliers et des milliers de connexions simultan√© sans que cela impacte les performances de l‚Äôapplication.

## Les API

#### Qu'est-ce qu'une API ?

Une **API** (_Application Programming Interface_, ou interface de programmation d'applications) est un ensemble de r√®gles et de conventions qui permet √† des applications logicielles de communiquer entre elles. Elle agit comme un interm√©diaire, facilitant l'√©change d'informations ou de services entre diff√©rents syst√®mes.

#### Composantes cl√©s d'une API :

1. **Interface**

   - Une API d√©finit **comment** une application peut interagir avec une autre, souvent via des points d'acc√®s ou des **endpoints**.
   - Exemple : Une application web peut utiliser une API pour demander des donn√©es d'un serveur.

2. **Requ√™te et r√©ponse**

   - Les interactions avec une API impliquent des **requ√™tes** envoy√©es par un client et des **r√©ponses** fournies par le serveur.
   - Exemple : Une requ√™te GET √† une API peut r√©cup√©rer des donn√©es, tandis qu'une requ√™te POST peut envoyer des informations.

3. **Protocole de communication**

   - Les API modernes utilisent souvent le protocole **HTTP/HTTPS**.

4. **Format des donn√©es**
   - Les API utilisent des formats standardis√©s pour √©changer des donn√©es, comme :
     - **JSON** (JavaScript Object Notation).
     - **XML** (Extensible Markup Language).

#### Types d'API

1. **API web**

   - Permet √† une application d'acc√©der √† des fonctionnalit√©s ou des donn√©es via Internet.
   - Exemple : L'API de Google Maps fournit des donn√©es de cartographie.

2. **API syst√®me**

   - Fournit un acc√®s aux fonctionnalit√©s du syst√®me d'exploitation.
   - Exemple : Une API syst√®me peut permettre d'acc√©der au syst√®me de fichiers.

3. **API de biblioth√®que/framework**

   - Fournit des fonctionnalit√©s pr√™tes √† l'emploi dans des biblioth√®ques ou des frameworks.
   - Exemple : L'API DOM pour manipuler des √©l√©ments HTML.
>>>>>>> origin/feat/add-vuejs
