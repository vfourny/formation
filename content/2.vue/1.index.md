---
title: Introduction
description: "D√©couvrir les concepts frontend et le framework Vue.js"
icon: i-mdi-door-open
helper:
  title: 'Liens utiles'
  links:
exercises:
  title: 'Exercices'
  links:
    - label: 'Corrig√© du cours'
      icon: 'i-mdi-account-school'
      target: '_blank'
      to: 'https://github.com/Seyrinian/nodejs-tutorial/tree/main'
    - label: 'Pokemon TCG'
      icon: 'i-mdi-pokeball'
      target: '_blank'
      to: 'https://classroom.github.com/a/1kY2YdAF'
---
# Introduction

## Pourquoi utiliser un framework front-end ?

Lorsque vous d√©veloppez une application web, vous pouvez choisir de coder votre interface utilisateur en utilisant des m√©thodes traditionnelles, comme du JavaScript pur ou jQuery. Cependant, ces m√©thodes peuvent rapidement devenir complexes et difficiles √† maintenir √† mesure que votre application grandit. Un framework front-end comme Vue.js vous permet de structurer votre code de mani√®re plus efficace et modulaire.

### Les avantages d'un framework front-end :

- **Modularit√©** : Le code est mieux structur√© gr√¢ce √† des composants r√©utilisables, facilitant ainsi la gestion du projet.
- **Maintenance simplifi√©e** : Un framework bien con√ßu facilite la mise √† jour de l'application et la correction des bugs.
- **Gain de productivit√©** : Avec des outils et des conventions int√©gr√©es, vous passez moins de temps √† configurer et plus de temps √† d√©velopper des fonctionnalit√©s.
- **R√©activit√©** : Un framework comme Vue.js rend l'interface utilisateur r√©active, c'est-√†-dire que l'UI se met √† jour automatiquement en fonction des modifications des donn√©es.

### üìå Pourquoi utiliser Vue.js ?

- **Facilit√© d'apprentissage** : Sa syntaxe est intuitive et la documentation est bien fournie.
- **Composants r√©utilisables** : Vue permet de structurer l'application en petits morceaux r√©utilisables, facilitant la gestion du code.
- **R√©activit√© int√©gr√©e** : Vue.js met √† jour automatiquement l'interface utilisateur en fonction des donn√©es, ce qui rend le d√©veloppement d'interfaces interactives tr√®s simple.
- **√âcosyst√®me complet** : Vue offre des outils comme Vue Router pour la navigation, Pinia pour la gestion d'√©tat, et Vite pour une compilation rapide.

## Installation et configuration

```sh
npm create vue@latest vujs-tutorial
cd vuejs-tutorial
npm install
npm run dev
```

### Bundler et Vite

Un outil de bundling pour le web est un logiciel qui prend en entr√©e plusieurs fichiers source (g√©n√©ralement du code JavaScript, mais aussi du CSS, des images, etc.) et qui les regroupe en un ou plusieurs fichiers "bundl√©s" optimis√©s pour √™tre d√©ploy√©s en production. L‚Äôobjectif principal est de r√©duire le nombre de requ√™tes HTTP, d‚Äôoptimiser la taille des fichiers (par exemple en supprimant les espaces inutiles ou en minifiant le code) et de g√©rer les d√©pendances de mani√®re efficace. Autrement dit, le bundler transforme une base de code modulaire en un format compr√©hensible et performant par les navigateurs web.

Vite se d√©marque particuli√®rement dans ce domaine pour plusieurs raisons :

| Caract√©ristique                | Description                                                                                                                                                  |
|--------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| D√©marrage ultra-rapide         | Utilise les modules ECMAScript natifs pour servir les fichiers √† la demande, √©vitant ainsi le build complet au d√©marrage.                                    |
| Pr√©-traitement des d√©pendances | Recourt √† esbuild pour pr√©-bundler rapidement les d√©pendances, r√©duisant la charge pendant le d√©veloppement.                                                  |
| Hot Module Replacement (HMR)   | Actualise uniquement les modules modifi√©s, offrant une exp√©rience de d√©veloppement plus fluide.                                                                |
| Configuration minimale         | Fonctionne avec peu, voire sans configuration initiale, permettant une int√©gration simple avec diff√©rents frameworks modernes (Vue, React, etc.).            |
| Production optimis√©e           | S'appuie sur Rollup pour g√©n√©rer des bundles performants et optimis√©s lors du d√©ploiement en production.                                                       |

Voici un compl√©ment de cours qui d√©crit comment l'instance Vue est initialis√©e gr√¢ce aux fichiers main.ts et App.vue, ainsi que leur r√¥le par rapport √† index.html.

---

## Initialisation de Vue avec main.ts et App.vue

### main.ts

Le fichier main.ts est le point d'entr√©e principal de l'application. C'est ici que l'instance Vue est cr√©√©e et que le composant racine (souvent App.vue) est mont√© dans l'√©l√©ment HTML pr√©vu √† cet effet, g√©n√©ralement d√©fini dans index.html. Un exemple typique de main.ts ressemble √† ceci :

```ts
// main.ts
import { createApp } from 'vue'
import App from './App.vue'

// Cr√©e une instance de l'application Vue √† partir du composant App
const app = createApp(App)

// Monte l'application dans l'√©l√©ment HTML qui a pour id "app"
app.mount('#app')
```

Les points cl√©s √† retenir :
- On importe la fonction `createApp` depuis Vue et le composant racine `App`.
- On cr√©e l'application avec `createApp(App)`.
- L'appel `mount('#app')` associe l'application √† l'√©l√©ment DOM dont l'id est "app". Cet √©l√©ment se trouve dans le fichier index.html.

### App.vue

Le fichier App.vue est le composant racine de l'application Vue. Il contient g√©n√©ralement trois sections principales :

1. Le bloc `<template>` qui d√©finit la structure HTML du composant.
2. Le bloc `<script>` qui contient la logique JavaScript (ou TypeScript) du composant.
3. Le bloc `<style>` qui permet d'ajouter des styles CSS sp√©cifiques √† ce composant.

Voici un exemple basique de structure d'un fichier App.vue :

```vue
<!-- App.vue -->
<template>
  <div id="app">
    <h1>Bienvenue dans l'application Vue.js</h1>
    <p>Ceci est le composant racine.</p>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'App'
  // Vous pouvez d√©finir ici les donn√©es, m√©thodes, etc.
})
</script>

<style>
/* Styles sp√©cifiques √† App.vue */
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  text-align: center;
}
</style>
```

Les points essentiels :
- Le `<template>` d√©finit le rendu visuel du composant.
- Le `<script>` contient la logique du composant (pour g√©rer l'√©tat, les m√©thodes, etc.).
- Le `<style>` permet de styliser le composant de mani√®re encapsul√©e.

### R√¥le par rapport √† index.html

Le fichier index.html est la page HTML principale qui charge l'application Vue. Il contient un √©l√©ment conteneur (souvent un div avec l'id "app") dans lequel Vue va injecter le contenu g√©n√©r√© par l'application.

Exemple simplifi√© de index.html :

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>Mon Application Vue</title>
  </head>
  <body>
    <!-- Point de montage pour l'application Vue -->
    <div id="app"></div>

    <!-- Le bundle g√©n√©r√© (incluant main.ts et App.vue compil√©s) est inject√© ici par Vite -->
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

Explications :
- Le `<div id="app"></div>` sert de conteneur dans lequel Vue montera l'application cr√©√©e dans main.ts.
- Le fichier main.ts est r√©f√©renc√© en tant que module JavaScript. Gr√¢ce √† ce chargement, l'instance Vue est cr√©√©e, le composant App.vue est rendu et tout le contenu de l'application est inject√© dans le conteneur d√©fini dans index.html.

---

En r√©sum√©, main.ts est le point d'entr√©e qui cr√©e et monte l'application Vue en ciblant un √©l√©ment pr√©d√©fini dans index.html, tandis que App.vue est le composant racine qui d√©finit l'interface et la logique initiale de l'application. Cette structure modulaire permet de s√©parer la configuration d'initialisation du rendu et de la logique de l'interface utilisateur, facilitant ainsi l'organisation et la maintenance du code.
